Coding Guide for OpenTESArena
-----------------------------
This is a master list for the various practices to consider when programming for this project, ordered alphabetically. You're not expected to memorize all of it! Just keep the common things like bounds-checking, **nullptr**, and automatic memory management via **std::unique_ptr** in mind. The description of each bullet tells some details about that feature, as well as why to use it over existing language features.

#### Primary C++ features
- **auto** - used to reduce the number of times to re-type something, to allow the right hand side of a statement to determine the type, or to reduce the amount of screen/line space being used unnecessarily. It is not frequently used on simple types like **int**, or when Intellisense or other completion options are available. However, using **auto** on a numeric type might reveal more specific information, like **std::vector::size_type** instead of **int**, which is a really long type name, but it's type safe and there's probably no loss of data, so if **auto** is used in one place, it should be used elsewhere both for consistency, and to conceal the inherited long type names that are put together by combining calculations from various things. **auto** shouldn't be used for declaring function return values, but it's likely that the language developers got the idea for that from lambdas being able to have their return types deduced.
- **constexpr** - for guaranteed compile-time constant expressions (assuming it's for performance?).
- **container.at(index)** - instead of **container[index]**. Bounds-checking is especially handy when working with the annoying zero-based indexing of C-like languages, where it's entirely bewildering to ask for the zeroth object in an array when every English speaking person (and others) asks for the first object and gets the first object! The only reason C is designed with zero-based indexing is to retain orthogonality with its base address + size multiplication for getting pointer offsets of various types without needing to do subtraction when wanting the first object.
- **explicit** - for restricting constructors from doing implicit type conversions on their parameters, even if they're somewhat safe, just to keep everything running as intended. It's not really necessary to use this keyword unless the code is written with a lot of syntax shortcuts, such as letting implicit type conversions happen all over the place.
- **Lambdas** - **\[capture](args) -> optional_return_type {}**. For encapsulating expressions that are used in only one place, and to prevent temporary local variables from unnecessarily contaminating the function namespace. The syntax outside of the curly braces is a bit odd though, because it seems to put the return type after the arguments, which is likely not found anywhere else in the language. Why not design it like an inline function? Perhaps because writing the return type is optional, and if it were the first thing after the equals sign, then it might cause some confusion if it were there sometimes and not other times, given its more "up front" placement in that case.
- **nullptr** - for more type safety than **NULL**, which is usually just **(void*)0**. The **std::nullptr_t** is its own type which can't be confused with an integer type, but can be used anywhere a pointer is used.
- **override** - for being explicit about what virtual methods are being overridden. For some reason, VS2013's Intellisense doesn't reliably detect that a method is actually overriding a base virtual method, but it still compiles nonetheless.
- **Range-based for loop** - **for (auto &item : container)**. This loop replaces the cumbersome iterator loop.
- **static_assert** - for compile-time pre- and post-condition checking. The compilation will fail if a static assert fails. It is not for runtime assertions. That's what assert() is for.
- **std::array** - the **std::vector** container uses dynamic allocation which is often times unnecessary, especially in situations where the vector's size is determined at compile time. This is another way of implicitly restricting ranges that should never be reached in the lifetime of an object, for instance when using bounds checking. Unfortunately, **std::array** might not have any special constructors, like with iterators for example, so it has to be initialized manually with a loop for any data that's more than trivial. They can be copied to with **std::copy**, though, and that uses iterators.
- **std::function** - for more flexibility and standard library compatibility than function pointers, among other things.
- **std::list/forward_list** - for some handy extra container types. **std::list** is like a doubly linked list; for quick insertions but slower access than a **std::vector**.
- **std::min/max** - in the **algorithm** header file. These min and max functions are templated, and return a **const&** instead of a value, which may be a desired feature.
- **std::move()** - mostly for **unique_ptrs**, since they can't be copied, but also for moving things instead of copying them, which is a performance bonus.
- **std::string** - because **char*** is error-prone, lots of busy work for **strcat()/strcpy()**, and doesn't allow for nice things like the concatenation (**+**) operator. All allocations and de-allocations are taken care of, too, and you can even get a **const char*** via **std::string::c_str()** if necessary. There is always the argument about performance, but what is there that needs to be done ten million times a second that requires character manipulation? Use **char*** in that situation, but everywhere else, use **std::string**. There might be a need to use the wide character type in the future, if allowing for Unicode or other multi-byte formats, and **std::wstring** provides that, though its exact size can vary between platforms.
- **std::uniform_distributions** - because **rand()** isn't professionally accurate enough. There don't seem to be any significant changes in performance from using a **std::uniform_real_distribution** paired with a **std::default_random_engine** in performance-critical applications.
- **std::vector** - the **vector** is the go-to array type in C++. It's dynamically resizable, it guarantees that all items are contiguous (in newer standards), and it calls the destructor of each of its items once it goes out of scope. The programmer still needs to call **delete** or other relevant freeing functions on each of those items if they use the heap.
- **Strongly typed enums** - using **enum class {};**. They allow for more type safety, and as an easy way to restrict the range of accepted values for an integer type; i.e., **int** has ~4 billion possible values, while a strongly typed enum could have only 4 or 5 values which are the only relevant ones. They are especially nice as keys for mapping to certain things, like file names or specific images, instead of using whole strings for mapping. It guarantees access correctness by restricting range on something that doesn't need to have 4 billion possible values! It's an added bonus if a strongly typed enum does not implicitly convert to an integer type.

#### Other notable C++ features
- **Compile-time information** - like **std::is_constructable**, etc.. They are essentially templated structs.
- **Constructor initializer lists** - the initializer list for a constructor essentially allows the programmer to override the default constructor behavior for all non-intrinsic member variables for a class or struct. But by their existence, the programmer has two options for doing the exact same thing, so they will be left having to choose where their members get initialized: only in the initializer list, partially in the initializer list, or only in the constructor body (which also has the overhead of also calling default constructors for each member object, which is unnecessary). Perhaps it should be a compile-time error if a non-intrinsic member is left uninitialized in the constructor body. They are initialized either way as it is already.
- **SIMD vector types** - like **float4** (not until C++17). These are good for when doing performance code, as they can more easily be recognized by the compiler as a vector operation, and can generally be converted to vector machine code (without needing to do intrinsics?). They are also good as a replacement for things like an RGBA color struct, where an **int4** would "just carry less weight", and would (hopefully) come with typical operators like addition and multiplication which would otherwise need to be explicitly written when using a struct or class. There would need to be some rules on how they are passed around though, because at a glance, they seem like something that would need to be passed by reference to keep from losing performance due to copy semantics; this is not the case in an OpenCL kernel. They should probably be part of a header file instead of a built-in type, because they might only be used in certain applications like computer graphics, or applications where parallel operations were the primary objective.
- **std::chrono** - for timing operations accurately in a cross-platform way. No more Linux **sys/time.h** includes or Windows **QuerySomeFrequency()** functions necessary.
- **"std::container::" namespace** - like **std::vector::iterator**. Just to have the extra C++ wrapper around objects for type safety and flexibility. All of this compiles to relatively fast code anyway, so these features should be used for enhancing manageability. In most cases, **auto** can deduce these long type names, too, which should be the preferred course of action.
- **Templates** - Lots of compile-time power, and they provide an entire Turing-complete meta-programming language. Good for allowing similar types like **float** and **double** to be used for the same class as well.

#### C++ features to avoid
- **C-style arrays** - There is little value to prolonging the C-style array in C++ now that there are convenience types like **std::array** that are designed to provide everything from before with extra options like size querying and bounds-checking all at the programmer's discretion. The programmer can use **container[index]** instead of **container.at(index)** if they want slightly more performance at bottlenecks, but again, high speed performance isn't necessary for most things, so the bare-metal style of C isn't really something a modern C++ programmer should be going to now. Besides, is the behavior of arrays decaying to pointers and having to keep their size separate a desired trait of a language? A **std::array** can be passed by reference, and that is definitely a welcome feature.
- **C-style casts** - Sometimes the burden of using **const_cast** and **reinterpret_cast** just gets annoying at times, but they should still be used in cases where the amount to type is not unnecessarily extraordinary. It's better to figure something out at compile time than runtime, and **static_cast** provides that very thing.
- **dynamic_cast** - This type of cast is a bit unsafe, mostly because it relies on runtime information, and can return null if unsuccessful. It isn't necessarily bad practice to use it, but it is bad practice to use it where it is not necessary. Overall, there are ways around requiring runtime type information; perhaps a change in design could prevent this cast from being needed. One workaround is to have derived classes implement an abstract method that returns the relevant information about their identity, like an enum. Another workaround is to have a factory that returns the requested instance of a class, and another is to use the **typeid** operator to compare types of objects (but this still uses runtime type information).
- **new** - only discouraged when not used with a **unique_ptr** constructor. With the addition of pointer wrappers like **unique_ptr** and **shared_ptr**, using manual memory allocation isn't in the best C++ style anymore, though it once was, as a type-safe leap forward from **malloc()**. The pointer wrappers make manually calling **delete** a thing of the past because they automatically call it in their destructors at the end of scope.

#### SDL2 notes
- Since SDL is a C library, not all of it can be directly interacted with on the modern C++ level. There are some things that can be wrapped into a class though, like **SDL_Surface** going into a **Surface** class.
- Use **SDL_FreeSurface()**, not **delete** or **std::unique_ptr**, on an **SDL_Surface**. This also counts for other SDL types like **SDL_Window**, **SDL_Renderer**, and so on, which have their own dedicated free functions. An **SDL_Rect** is not on the SDL heap, so it can be in a **std::unique_ptr**.

#### Side notes
- Do not use assignments in conditions; i.e., **if ((result = doFunction()) == 0)**. Make a local variable to store the result as a **bool** instead.
- Use pre-increment everywhere, and only as a statement by itself. While post-incrementing is probably fine, there are some places where the language does some extra work behind the scenes for it (possibly with iterators? Temporaries?).
- When a function's return type is **const&**, verify that the lifetime of the referenced value is longer than the lifetime of the function call. It's typically okay if that reference is referring to a class or struct member.
- Obtain random numbers through an instance of the **Random** class. Do not use **rand()** or **srand()**.
- Use the tools of C++ to discover bugs at compile time and to make busy-work things become automatic and type safe.
- Compile with all warnings! If all warnings means like 5000 pointless warnings, then it's okay to step it down a notch.
- All programmers can make mistakes if they're not perfectly careful! Take precautions by thinking ahead and using convenient features that don't require babysitting and can simply be written and forgotten. One of the primary reasons C++ exists is to allow convenience without sacrificing performance, so these neat features executing in the code should generally not add up to that much overhead.
